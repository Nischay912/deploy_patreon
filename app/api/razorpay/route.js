// step321: we had in Payment.js that done was set to "false" initially there : but we have to verify the payment and if its done we have to make done to "true" else keep it false only ; so lets do that here now below.

// step322: we import the below file to create HTTP responses in NextJs : the response means an HTTP response that your server-side code sends back to the browser, frontend, or API caller after processing a request.
import { NextResponse } from "next/server";

// step323: the following import now : checks if the payment signature sent by Razorpay is valid. It ensures the payment data wasn’t tampered with during the transfer from Razorpay to your server.
import { validatePaymentVerification } from "razorpay/dist/utils/razorpay-utils";

// step324: The below package now allows to interact with Razorpay’s API from your server.
import Razorpay from "razorpay";

// step325: these below packages now are as usual like we used earlier too
import Payment from "@/models/Payment";
import connectDb from "@/db/connectDb";
import User from "@/models/User";

// step326: lets now make a POST request function : it runs automatically when someone sends a POST request to that route ; and "req" is the HTTP request object coming from the client.

// step327: use async as we have to use await in the function below too.
export const POST = async(req) =>{

    // step328: we now use the below code to connect to the database like we did earlier too ; so we need to connect to database first before doing anything in the database there.
    await connectDb()

    // step329: this below line now : reads the body of the POST request as FormData (key-value pairs) which are often sent from HTML forms ; so it extracts the form values that were submitted via POST request. 
    let body = await req.formData()

    // step330: now : req.formData() does not give you a normal JavaScript object — it returns a FormData object, which is a special data structure designed for file uploads and HTML form submissions ; so we need to convert it to a plain JavaScript object using the below code , which converts a list of key-value pairs (like FormData) into a normal JavaScript object and so we update the body back to a Javascript object now below.
    body = Object.fromEntries(body)

    // step331: we had a field "oid" in Payments collection , which will store the razorpay order id once payment done ; so we find it below and use await as findOne is asynchronous and needs await.
    let p = await Payment.findOne({oid : body.razorpay_order_id})

    // step332: then we check if its null i.e. no such document found with that oid in our collection , then we stop the function execution and send a response back with the error message below.
    if(!p){
        return NextResponse.json({success : false , message : "Order id not found"})
    }

    // step447: now we are trying to fetch the secret from the database as the user is submitting it in the dashboard form there & then use it instead of the "process.env.KEY_SECRET" being used everywhere here.

    // step448: so we are finding the document with the username equal to the "to_user" of "p" i.e. the Payments collection document i.e. search the "User" collection for the document having the "username" equal to the "to_user" which is the current logged in user currently there ; this was done as username in Users collection and to_user in payments collection are the same ; so we are accessing the logged in user , which has the username === to the to_user of payments collection ; so we can get the two collections connected and then use the correct user's secret now ehre below.
    let user = await User.findOne({username : p.to_user})

    // step449: then we extract the razorpay secret from that document in a variable below.
    const secret = user.razorpaysecret

    // step333: if no error found above means we have not returned back from the function as "if" above didn't run ; so we go to verify the payment below.

    // step334: signature verification is a security step to confirm that the payment information you received is actually from Razorpay and not tampered with by anyone in between.
    /*
step335:
    When a payment happens, Razorpay sends back 3 important pieces of data to your backend:

    razorpay_order_id –> the ID of the order you created earlier.
    razorpay_payment_id –> the unique payment ID generated by Razorpay.
    razorpay_signature –> a hash signature created by Razorpay using their secret key.

    This happens because when Razorpay finishes the payment, it sends back data to your server in the request body (usually as a POST request) , so it sent it in the "body" above maybe like this -
        {
            "razorpay_order_id": "order_Ef80WJDPBmAeNt",
            "razorpay_payment_id": "pay_Ef8z6nXxYd1vO1",
            "razorpay_signature": "8f8a9a7c6b45..."
        }

    So, we used a function provided by razorpay below : we pass the order_id and order things we recieved and using the function it tries to create a signature again using our KEY_SECRET too passed below & then verifies if it matches to the one it generated before or not.

    It compares your generated hash with the razorpay_signature from Razorpay. If they match → payment is genuine (no tampering). If they don’t match → payment might be fake or modified.
    
    The result is stored in xx ; so the value of xx will be true if verified, otherwise false.

    // step336: this syntax from taken from razorpay documentation and used below.
    */

    // step450: so now we replace the "env" variable to "secret" variable as it now contains the razorpaysecret to be used there , here below.
    // let xx = validatePaymentVerification({"order_id" : body.razorpay_order_id , "payment_id" : body.razorpay_payment_id} , body.razorpay_signature , process.env.KEY_SECRET)

    let xx = validatePaymentVerification({"order_id" : body.razorpay_order_id , "payment_id" : body.razorpay_payment_id} , body.razorpay_signature , secret)

    // step451: see where all this KEY_SECRET is being used by clickon search icon on sidebar and search for KEY_SECRET : which will tell where all its being used and then we use the same logic used here to replace them also with the secret fetched from databse instad of the env folder being used earlier there/here.

    // step452: so now see the next steps in useractions.js file there now.
    
    // stepp337: now if the verification was succesful i.e. xx returned true : then -
    if(xx){

        // step338: we find the document in MongoDB that matches the oid = razorpay_order_id & update its done field to "true" and then new : "true" means it will return the updated document and not the old one. 
        const updatedPayment = await Payment.findOneAndUpdate({oid : body.razorpay_order_id} , {done : true} , {new : true})

        // step339: then we redirect the user back to the localhost:3000/its username that was in the 'to_user' field of the updated Payment document there , as we made to_user field for username in Payment.js there.

        // step340:the ?paymentdone=true is just a query parameter there that indicates payment was done ; it doesn't redirects us anywhere else , but just makes the URL has a parameter showing paymentdone=true to be there

        return NextResponse.redirect(`${process.env.URL}/${updatedPayment.to_user}?paymentdone=true`)
    }

    else{

        // step341: else we send a JSON response to server saying the following error below ; and the "done" field also not updated and remains false in that case here.
        return NextResponse.json({success : false , message : "Payment Verification Failed"})

        // step342: so overall here : the redirection to new page after payment done is similar to makng a GET request by typing a url ; so it sends a POST request to the POST we wrote above in this file itself and does the cation told to do there.
    }

    // step343: now if we do a payment , it redirects us to the profile page back with URL parameter ?paymentdone=true & also it now : logs it in the database with "done = true" ; but if you cancel the transaction midway or close the window itself , it logs the information in database but with a "done = false" : SO THE RAZORPAY VERIFICATION IS WORKING CORRECTLY NOW HERE.

    // step344: now we have to print all the "done = true" payments and display in the supporters list there.

    // step345: so go to PaymentPage.js for next steps now there.

}